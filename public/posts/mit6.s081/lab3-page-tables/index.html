<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lab3: page tables | momo blog</title>
<meta name="keywords" content="OS">
<meta name="description" content="Lab链接：Lab: page tables
Lab源码：momo/MIT-6S081/pgtbl - Gitee.com
xv6的页表机制 xv6采用64位地址，一页大小为4KB(4096B)
xv6的页表项（64位）
页表项代表的页的物理地址（10~53） 页表的操作权限（0~9） xv6的虚拟地址（64位）➡物理地址转换
一级页表L2&#43;二级页表L1&#43;三级页表L0&#43;三级页表中的偏移量Offset（9&#43;9&#43;9&#43;12）
内核拥有自己的页表。当进程进入内核态时，操作系统将内核根页表存入页表基地址寄存器；进程退出内核态时切换回进程根页表。
进程在内核态执行程序时，使用内核根页表找到内核程序中虚拟地址对应的物理地址。
xv6内核视角下，虚拟地址与物理地址对应关系 低于0x80000000：分配给I/O设备，作为外部设备的寄存器
direct mapping memory-mapped：内核处理这个范围的虚拟地址时直接定位对应的物理地址，即外部设备接口，不需要通过RAM访问外部设备。 0x80000000~PHYSTOP（0x86400000）：存储内核程序、数据
kernel text：内核代码，R-X，direct mapping kernel data：RW-，防止恶意程序写入kernel data并执行 kernel stack：系统会为每个进程分配一页保护页（Guard page）以及一页内核栈（Kstack）。保护页有效位被设置为 0 ，并且不分配对应的物理页。Kstack发生溢出，数据试图进入Guard page，由于Guard page无法转换为有效的物理地址，会触发缺页异常（page fault） trampoline：RX-， xv6内核启动（kernel/main.c），创建内核页表：
申请一个空页表 关联IO设备的地址 关联内核程序，内核程序已成功加载到物理地址范围为 KERNBASE 至 exect 的区域，起始虚拟地址设定为 KERNBASE 关联trampoline 从最高虚拟地址往下，为每个进程分配一个内核栈页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #define TRAMPOLINE (MAXVA - PGSIZE) #define KERNBASE 0x80000000L #define PHYSTOP (KERNBASE &#43; 128*1024*1024) extern char trampoline[]; // trampoline.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/mit6.s081/lab3-page-tables/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8f541c169a12d0d6bb704527bb78f6481fb4f5a39b7171fc16fab8c03ae6b1bd.css" integrity="sha256-j1QcFpoS0Na7cEUnu3j2SB&#43;09aObcXH8Fvq4wDrmsb0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/mit6.s081/lab3-page-tables/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Lab3: page tables" />
<meta property="og:description" content="Lab链接：Lab: page tables
Lab源码：momo/MIT-6S081/pgtbl - Gitee.com
xv6的页表机制 xv6采用64位地址，一页大小为4KB(4096B)
xv6的页表项（64位）
页表项代表的页的物理地址（10~53） 页表的操作权限（0~9） xv6的虚拟地址（64位）➡物理地址转换
一级页表L2&#43;二级页表L1&#43;三级页表L0&#43;三级页表中的偏移量Offset（9&#43;9&#43;9&#43;12）
内核拥有自己的页表。当进程进入内核态时，操作系统将内核根页表存入页表基地址寄存器；进程退出内核态时切换回进程根页表。
进程在内核态执行程序时，使用内核根页表找到内核程序中虚拟地址对应的物理地址。
xv6内核视角下，虚拟地址与物理地址对应关系 低于0x80000000：分配给I/O设备，作为外部设备的寄存器
direct mapping memory-mapped：内核处理这个范围的虚拟地址时直接定位对应的物理地址，即外部设备接口，不需要通过RAM访问外部设备。 0x80000000~PHYSTOP（0x86400000）：存储内核程序、数据
kernel text：内核代码，R-X，direct mapping kernel data：RW-，防止恶意程序写入kernel data并执行 kernel stack：系统会为每个进程分配一页保护页（Guard page）以及一页内核栈（Kstack）。保护页有效位被设置为 0 ，并且不分配对应的物理页。Kstack发生溢出，数据试图进入Guard page，由于Guard page无法转换为有效的物理地址，会触发缺页异常（page fault） trampoline：RX-， xv6内核启动（kernel/main.c），创建内核页表：
申请一个空页表 关联IO设备的地址 关联内核程序，内核程序已成功加载到物理地址范围为 KERNBASE 至 exect 的区域，起始虚拟地址设定为 KERNBASE 关联trampoline 从最高虚拟地址往下，为每个进程分配一个内核栈页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #define TRAMPOLINE (MAXVA - PGSIZE) #define KERNBASE 0x80000000L #define PHYSTOP (KERNBASE &#43; 128*1024*1024) extern char trampoline[]; // trampoline." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/mit6.s081/lab3-page-tables/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-09-07T00:00:00+00:00" /><meta property="og:site_name" content="momo blog" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Lab3: page tables"/>
<meta name="twitter:description" content="Lab链接：Lab: page tables
Lab源码：momo/MIT-6S081/pgtbl - Gitee.com
xv6的页表机制 xv6采用64位地址，一页大小为4KB(4096B)
xv6的页表项（64位）
页表项代表的页的物理地址（10~53） 页表的操作权限（0~9） xv6的虚拟地址（64位）➡物理地址转换
一级页表L2&#43;二级页表L1&#43;三级页表L0&#43;三级页表中的偏移量Offset（9&#43;9&#43;9&#43;12）
内核拥有自己的页表。当进程进入内核态时，操作系统将内核根页表存入页表基地址寄存器；进程退出内核态时切换回进程根页表。
进程在内核态执行程序时，使用内核根页表找到内核程序中虚拟地址对应的物理地址。
xv6内核视角下，虚拟地址与物理地址对应关系 低于0x80000000：分配给I/O设备，作为外部设备的寄存器
direct mapping memory-mapped：内核处理这个范围的虚拟地址时直接定位对应的物理地址，即外部设备接口，不需要通过RAM访问外部设备。 0x80000000~PHYSTOP（0x86400000）：存储内核程序、数据
kernel text：内核代码，R-X，direct mapping kernel data：RW-，防止恶意程序写入kernel data并执行 kernel stack：系统会为每个进程分配一页保护页（Guard page）以及一页内核栈（Kstack）。保护页有效位被设置为 0 ，并且不分配对应的物理页。Kstack发生溢出，数据试图进入Guard page，由于Guard page无法转换为有效的物理地址，会触发缺页异常（page fault） trampoline：RX-， xv6内核启动（kernel/main.c），创建内核页表：
申请一个空页表 关联IO设备的地址 关联内核程序，内核程序已成功加载到物理地址范围为 KERNBASE 至 exect 的区域，起始虚拟地址设定为 KERNBASE 关联trampoline 从最高虚拟地址往下，为每个进程分配一个内核栈页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #define TRAMPOLINE (MAXVA - PGSIZE) #define KERNBASE 0x80000000L #define PHYSTOP (KERNBASE &#43; 128*1024*1024) extern char trampoline[]; // trampoline."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MIT6.S081-Lab",
      "item": "http://localhost:1313/posts/mit6.s081/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Lab3: page tables",
      "item": "http://localhost:1313/posts/mit6.s081/lab3-page-tables/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab3: page tables",
  "name": "Lab3: page tables",
  "description": "Lab链接：Lab: page tables\nLab源码：momo/MIT-6S081/pgtbl - Gitee.com\nxv6的页表机制 xv6采用64位地址，一页大小为4KB(4096B)\nxv6的页表项（64位）\n页表项代表的页的物理地址（10~53） 页表的操作权限（0~9） xv6的虚拟地址（64位）➡物理地址转换\n一级页表L2+二级页表L1+三级页表L0+三级页表中的偏移量Offset（9+9+9+12）\n内核拥有自己的页表。当进程进入内核态时，操作系统将内核根页表存入页表基地址寄存器；进程退出内核态时切换回进程根页表。\n进程在内核态执行程序时，使用内核根页表找到内核程序中虚拟地址对应的物理地址。\nxv6内核视角下，虚拟地址与物理地址对应关系 低于0x80000000：分配给I/O设备，作为外部设备的寄存器\ndirect mapping memory-mapped：内核处理这个范围的虚拟地址时直接定位对应的物理地址，即外部设备接口，不需要通过RAM访问外部设备。 0x80000000~PHYSTOP（0x86400000）：存储内核程序、数据\nkernel text：内核代码，R-X，direct mapping kernel data：RW-，防止恶意程序写入kernel data并执行 kernel stack：系统会为每个进程分配一页保护页（Guard page）以及一页内核栈（Kstack）。保护页有效位被设置为 0 ，并且不分配对应的物理页。Kstack发生溢出，数据试图进入Guard page，由于Guard page无法转换为有效的物理地址，会触发缺页异常（page fault） trampoline：RX-， xv6内核启动（kernel/main.c），创建内核页表：\n申请一个空页表 关联IO设备的地址 关联内核程序，内核程序已成功加载到物理地址范围为 KERNBASE 至 exect 的区域，起始虚拟地址设定为 KERNBASE 关联trampoline 从最高虚拟地址往下，为每个进程分配一个内核栈页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #define TRAMPOLINE (MAXVA - PGSIZE) #define KERNBASE 0x80000000L #define PHYSTOP (KERNBASE + 128*1024*1024) extern char trampoline[]; // trampoline.",
  "keywords": [
    "OS"
  ],
  "articleBody": "Lab链接：Lab: page tables\nLab源码：momo/MIT-6S081/pgtbl - Gitee.com\nxv6的页表机制 xv6采用64位地址，一页大小为4KB(4096B)\nxv6的页表项（64位）\n页表项代表的页的物理地址（10~53） 页表的操作权限（0~9） xv6的虚拟地址（64位）➡物理地址转换\n一级页表L2+二级页表L1+三级页表L0+三级页表中的偏移量Offset（9+9+9+12）\n内核拥有自己的页表。当进程进入内核态时，操作系统将内核根页表存入页表基地址寄存器；进程退出内核态时切换回进程根页表。\n进程在内核态执行程序时，使用内核根页表找到内核程序中虚拟地址对应的物理地址。\nxv6内核视角下，虚拟地址与物理地址对应关系 低于0x80000000：分配给I/O设备，作为外部设备的寄存器\ndirect mapping memory-mapped：内核处理这个范围的虚拟地址时直接定位对应的物理地址，即外部设备接口，不需要通过RAM访问外部设备。 0x80000000~PHYSTOP（0x86400000）：存储内核程序、数据\nkernel text：内核代码，R-X，direct mapping kernel data：RW-，防止恶意程序写入kernel data并执行 kernel stack：系统会为每个进程分配一页保护页（Guard page）以及一页内核栈（Kstack）。保护页有效位被设置为 0 ，并且不分配对应的物理页。Kstack发生溢出，数据试图进入Guard page，由于Guard page无法转换为有效的物理地址，会触发缺页异常（page fault） trampoline：RX-， xv6内核启动（kernel/main.c），创建内核页表：\n申请一个空页表 关联IO设备的地址 关联内核程序，内核程序已成功加载到物理地址范围为 KERNBASE 至 exect 的区域，起始虚拟地址设定为 KERNBASE 关联trampoline 从最高虚拟地址往下，为每个进程分配一个内核栈页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #define TRAMPOLINE (MAXVA - PGSIZE) #define KERNBASE 0x80000000L #define PHYSTOP (KERNBASE + 128*1024*1024) extern char trampoline[]; // trampoline.S extern char etext[]; // kernel.ld sets this to end of kernel code. // Initialize the one kernel_pagetable void kvminit(void) { kernel_pagetable = kvmmake(); } // Make a direct-map page table for the kernel. pagetable_t kvmmake(void) { pagetable_t kpgtbl; kpgtbl = (pagetable_t) kalloc(); memset(kpgtbl, 0, PGSIZE); // uart registers kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // PLIC kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we'll make use of. kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); // map kernel stacks proc_mapstacks(kpgtbl); return kpgtbl; } 进程处于内核态时栈的分配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // map kernel stacks beneath the trampoline, // each surrounded by invalid guard pages. #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE) // Allocate a page for each process's kernel stack. // Map it high in memory, followed by an invalid // guard page. void proc_mapstacks(pagetable_t kpgtbl) { struct proc *p; for(p = proc; p \u003c \u0026proc[NPROC]; p++) { char *pa = kalloc(); if(pa == 0) panic(\"kalloc\"); uint64 va = KSTACK((int) (p - proc)); kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); } } xv6进程在用户态下，虚拟内存空间分布 text：代码区 data：静态数据区 stack：栈 guard page：位于栈和数据区之间，避免栈溢出越界覆盖数据区 heap：堆 trampframe：进程信息 trampoline：存储切换内核态的指令 xv6创建用户进程，内存初始化：创建进程三级页表 + 加载程序\n① 创建进程三级页表\n申请一个空页表 将trampoline、trapframe的物理页表地址与虚拟地址联系起来 trapframe页表之前已经申请了，其首地址为p-\u003etrapframe trampoline一段声明在trampoline.S中的程序，用于实现内核用户态之间的切换。所有进程的trampoline虚拟地址都映射到同一物理地址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #define MAXVA (1L \u003c\u003c (9 + 9 + 9 + 12 - 1)) #define TRAMPOLINE (MAXVA - PGSIZE) #define TRAPFRAME (TRAMPOLINE - PGSIZE) extern char trampoline[]; // trampoline.S // Create a user page table for a given process, // with no user memory, but with trampoline pages. pagetable_t proc_pagetable(struct proc *p) { pagetable_t pagetable; // An empty page table. pagetable = uvmcreate(); if(pagetable == 0) return 0; // map the trampoline code (for system call return) // at the highest user virtual address. // only the supervisor uses it, on the way // to/from user space, so not PTE_U. if(mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) \u003c 0){ uvmfree(pagetable, 0); return 0; } // map the trapframe just below TRAMPOLINE, for trampoline.S. if(mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-\u003etrapframe), PTE_R | PTE_W) \u003c 0){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; } return pagetable; } ② 加载进程程序\nsrc指针指向用户空间中存放进程代码的位置 用户进程统一从虚拟地址0映射程序，物理地址不是src，而是内核程序申请用于存放程序的页的物理地址 需要设置PTE_U=1，允许进程处于用户态时访问 1 2 3 4 5 6 7 8 9 10 11 12 void uvminit(pagetable_t pagetable, uchar *src, uint sz) { char *mem; if(sz \u003e= PGSIZE) panic(\"inituvm: more than a page\"); mem = kalloc(); memset(mem, 0, PGSIZE); mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U); memmove(mem, src, sz); } 清除用户内存：\n消除关联，否则会报错panic(“freewalk: leaf”); 递归清除页表：对于每个页表，先清除页表项为0，再回首页表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void freewalk(pagetable_t pagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026 PTE_V) \u0026\u0026 (pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0){ // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk((pagetable_t)child); pagetable[i] = 0; } else if(pte \u0026 PTE_V){ panic(\"freewalk: leaf\"); } } kfree((void*)pagetable); } // Free user memory pages, // then free page-table pages. void uvmfree(pagetable_t pagetable, uint64 sz) { if(sz \u003e 0) uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1); freewalk(pagetable); } 内存物理空间管理器 kernel/kalloc.h\n分配的地址为[内核空间~PHYSTOP]\n以一个页表为单位进行分配/回收\n通过链表追踪可用的空闲页表地址，allocator只有一个kmem内存空间，链表上的其他结点信息均存储在空闲页表的首部\n内存管理程序 映射虚拟地址➡物理地址mappages：自起始虚拟地址 va 起，连续 pa 字节的虚拟地址空间映射至起始于 pa 的物理地址空间\n不是直接从va算起，需计算起始地址对应页的首地址 循环处理每一页，包括检查该页是否已经被申请，设置对应的物理地址（函数参数）、有效位、权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 a, last; pte_t *pte; if(size == 0) panic(\"mappages: size\"); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;){ if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte \u0026 PTE_V) panic(\"mappages: remap\"); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; } return 0; } 给定虚拟地址➡物理地址 walk：在给定的三级页表中，查找虚拟地址 va 对应的页表项\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { if(va \u003e= MAXVA) panic(\"walk\"); for(int level = 2; level \u003e 0; level--) { pte_t *pte = \u0026pagetable[PX(level, va)]; if(*pte \u0026 PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; } } return \u0026pagetable[PX(0, va)]; } 1 Speed up system calls 题目 创建进程时，在虚拟地址USYSCALL映射一个只读页面。在此页面的开头，存储一个结构体usyscall（也在memlayout.h中定义），并以当前进程PID初始化该结构体。\n思路 在proc.h中增加struct usyscall *usyscall字段，用于存储共享页指针 allocproc()（进程创建时向内存申请空闲页）：申请新页，并将该页的指针地址存入p-\u003eusyscall字段中 proc_pagetable()（初始化进程虚拟内存空间，即申请用户内存空间的一级页表并实现已申请的特殊页的映射）：map USYSCALL页的物理地址和USYSCALL虚拟地址，形成的页表项添加到当前函数的页表中，设置该页权限为只读+允许用户访问，map失败要unmap之前成功map的页 proc_freepagetable()（释放用户内存空间的二级页表）：unmap usyscall页 freeproc()（进程销毁时清空该进程所占资源）：使用kfree()清除p-\u003eusyscall指向的物理页，对应的p-\u003eusyscall设置为0 报错：【panic：freewalk：leaf】\n定位：只有uvmfree调用了freewalk；多处调用uvmfree之前使用uvunmap unmap页表项\n释放页表之前，要先unmap页表的对应关系，即清除pte中的PTE_V为0：\n三、二级页表：(pte \u0026 PTE_V) \u0026\u0026 (pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0 一级页表：pte \u0026 PTE_V == 1 freewalk在释放一级页表时，如果一级页表项是有效的（pte \u0026 PTE_V == 1），则发生上述错误\n所以调用freewalk之前，需要unmap一级页表页表项\n源码 kernel/proc.h\n1 2 // struct proc struct usyscall *usyscall; kernel/proc.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void allocproc() { // Allocate a USYSCALL page for kernel to share with if((p-\u003eusyscallpage = (pagetable_t)kalloc()) == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } p-\u003eusyscall-\u003epid = p-\u003epid; } void proc_pagetable() { // map the usyscall just below USYSCALL if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-\u003eusyscall), PTE_R | PTE_U) \u003c 0){ uvmunmap(pagetable, USYSCALL, 1, 0); uvmfree(pagetable, 0); return 0; } } void freeproc() { if(p-\u003eusyscall) kfree((void*)p-\u003eusyscall); p-\u003eusyscall = 0; } // proc_freepagetable uvmunmap(pagetable, USYSCALL, 1, 0); 2 Print a page table​​ 题目 定义vmprint(pagetable_t)函数，打印pagetable_t页表及子页表中所有合法页表项的内容\n思路 定义两个函数：vmprint、vmsprint\nvmsprint(pagetable_t)\n遍历pagetable_t页表所有页表项 若当前页表项pte_t是合法的，打印相关信息 版本一：若当前页表项合法并且不存在RWX在权限，说明该页表项所指向的页表不是零级页表，递归调用vmsprint函数，打印当前页表项所指向的页表 版本二：无论当前页表项是不是指向零级页表，都进行递归，但是vmsprint函数需要增加一个levelc参数，表示当前页表是第几级页表。若是第三级，表示当前页表是零级页表，退出，不需要进行递归。 源码 kernel/vm.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void vmprint(pagetable_t pagetable) { printf(\"page table %p\\n\", pagetable); vmsprint(pagetable, 1); } void vmsprint(pagetable_t pagetable, int depth) { if(depth == 4) return; pte_t pte; uint64 child; for(int i = 0; i \u003c 512; ++i) { pte = pagetable[i]; if(pte \u0026 PTE_V) { printf(\"..\"); for(int k = 1; k \u003c depth; ++k) { printf(\" ..\"); } child = PTE2PA(pte); printf(\"%d: pte %p pa %p\\n\", i, pte, child); vmsprint((pagetable_t)child, depth+1); } } } C语言中，使用%p占位符打印指针变量的值，也就是虚拟地址。\n1 2 int *p; printf(\"the address is %p\\n\", p); 3 Detecting which pages have been accessed​ 题目 实现pgaccess系统调用，汇报哪些page在上次该系统调用之前被修改或访问过。包含以下三个参数：\nva：要检查的第一个user page的虚拟地址 checknum：待检查页数 dstva：位于用户空间，用于存储结果的缓冲区的虚拟地址（最低位对应第一页） 思路 获取pgaccess()系统调用的参数\n对于每一待检查的页：\n计算该页虚拟首地址va 基于walk函数，获取虚拟地址va在一级页表中的页表项（第29行代码错误，未获取最后一次PTE） 依据页表项的具体数值，对PTE_A进行检查。若PTE_A已被置位，就把该页的标识符写入掩码（mask）里。同时，为避免对后续检查产生干扰，需清除PTE_A标记 使用copyout()将结果写回用户空间 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 uint64 sys_pgaccess(void) { uint64 va, dstva, mask = 0L; int checknum; if(argaddr(0, \u0026va) \u003c 0) return -1; if(va \u003e= MAXVA) { panic(\"pgaccess virtual address no more than MAXVA\"); return -1; } if(argint(1, \u0026checknum) \u003c 0) return -1; if(checknum \u003e 64) checknum = 64; if(argaddr(2, \u0026dstva) \u003c 0) return -1; struct proc *p = myproc(); for (int i = 0; i \u003c checknum; ++i) { pte_t *pte; pagetable_t pagetable = p-\u003epagetable; for (int level = 2; level \u003e 0; --level) { pte = \u0026pagetable[PX(level, va)]; pagetable = (pagetable_t)PTE2PA(*pte); } pte = \u0026pagetable[PX(0, va)]; if(*pte \u0026 PTE_A) { mask |= 1 \u003c\u003c i; *pte \u0026= (~PTE_A); } va += PGSIZE; } if(copyout(p-\u003epagetable, dstva, (char *)\u0026mask, (uint64)(sizeof(mask))) \u003c 0) return -1; return 0; } ",
  "wordCount" : "1376",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-09-07T00:00:00Z",
  "dateModified": "2024-09-07T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/mit6.s081/lab3-page-tables/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "momo blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="momo blog (Alt + H)">momo blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/mit6.s081/">MIT6.S081-Lab</a></div>
    <h1 class="post-title entry-hint-parent">
      Lab3: page tables
    </h1>
    <div class="post-meta"><span title='2024-09-07 00:00:00 +0000 UTC'>September 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1376 words

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#xv6%e7%9a%84%e9%a1%b5%e8%a1%a8%e6%9c%ba%e5%88%b6" aria-label="xv6的页表机制">xv6的页表机制</a></li>
                <li>
                    <a href="#xv6%e5%86%85%e6%a0%b8%e8%a7%86%e8%a7%92%e4%b8%8b%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e4%b8%8e%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb" aria-label="xv6内核视角下，虚拟地址与物理地址对应关系">xv6内核视角下，虚拟地址与物理地址对应关系</a></li>
                <li>
                    <a href="#xv6%e8%bf%9b%e7%a8%8b%e5%9c%a8%e7%94%a8%e6%88%b7%e6%80%81%e4%b8%8b%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83" aria-label="xv6进程在用户态下，虚拟内存空间分布">xv6进程在用户态下，虚拟内存空间分布</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e7%89%a9%e7%90%86%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="内存物理空间管理器">内存物理空间管理器</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%a8%8b%e5%ba%8f" aria-label="内存管理程序">内存管理程序</a></li>
                <li>
                    <a href="#1-speed-up-system-calls" aria-label="1 Speed up system calls">1 Speed up system calls</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae" aria-label="题目">题目</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af" aria-label="思路">思路</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81" aria-label="源码">源码</a></li></ul>
                </li>
                <li>
                    <a href="#2-print-a-page-table" aria-label="2 Print a page table​​">2 Print a page table​​</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-1" aria-label="题目">题目</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af-1" aria-label="思路">思路</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81-1" aria-label="源码">源码</a></li></ul>
                </li>
                <li>
                    <a href="#3-detecting-which-pages-have-been-accessed" aria-label="3 Detecting which pages have been accessed​">3 Detecting which pages have been accessed​</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-2" aria-label="题目">题目</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af-2" aria-label="思路">思路</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81-2" aria-label="源码">源码</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Lab链接：<a href="https://pdos.csail.mit.edu/6.S081/2021/labs/pgtbl.html">Lab: page tables</a></p>
<p>Lab源码：<a href="https://gitee.com/Eleutheria666/mit-6s081/tree/pgtbl/">momo/MIT-6S081/pgtbl - Gitee.com</a></p>
<h2 id="xv6的页表机制">xv6的页表机制<a hidden class="anchor" aria-hidden="true" href="#xv6的页表机制">#</a></h2>
<p>xv6采用64位地址，一页大小为4KB(4096B)</p>
<p>xv6的页表项（64位）</p>
<ul>
<li>页表项代表的页的物理地址（10~53）</li>
<li>页表的操作权限（0~9）</li>
</ul>
<p><img loading="lazy" src="../../../images/image-20240726142304399.png" alt="image-20240726142304399"  />
</p>
<p>xv6的虚拟地址（64位）➡物理地址转换</p>
<p>一级页表L2+二级页表L1+三级页表L0+三级页表中的偏移量Offset（9+9+9+12）</p>
<p><img loading="lazy" src="../../../images/image-20240726142132505.png" alt="image-20240726142132505"  />
</p>
<p>内核拥有自己的页表。当进程进入内核态时，操作系统将内核根页表存入页表基地址寄存器；进程退出内核态时切换回进程根页表。</p>
<p>进程在内核态执行程序时，使用内核根页表找到内核程序中虚拟地址对应的物理地址。</p>
<h2 id="xv6内核视角下虚拟地址与物理地址对应关系">xv6内核视角下，虚拟地址与物理地址对应关系<a hidden class="anchor" aria-hidden="true" href="#xv6内核视角下虚拟地址与物理地址对应关系">#</a></h2>
<p><strong>低于0x80000000</strong>：分配给I/O设备，作为外部设备的寄存器</p>
<ul>
<li>direct mapping</li>
<li>memory-mapped：内核处理这个范围的虚拟地址时直接定位对应的物理地址，即外部设备接口，不需要通过RAM访问外部设备。</li>
</ul>
<p><strong>0x80000000~PHYSTOP（0x86400000）</strong>：存储内核程序、数据</p>
<ul>
<li>kernel text：内核代码，R-X，direct mapping</li>
<li>kernel data：RW-，防止恶意程序写入kernel data并执行</li>
<li>kernel stack：系统会为每个进程分配一页保护页（Guard page）以及一页内核栈（Kstack）。保护页有效位被设置为 0 ，并且不分配对应的物理页。Kstack发生溢出，数据试图进入Guard page，由于Guard page无法转换为有效的物理地址，会触发缺页异常（page fault）</li>
<li>trampoline：RX-，</li>
</ul>
<!-- raw HTML omitted -->
<p>xv6内核启动（kernel/main.c），创建内核页表：</p>
<ul>
<li>申请一个空页表</li>
<li>关联IO设备的地址</li>
<li>关联内核程序，内核程序已成功加载到物理地址范围为 <code>KERNBASE</code> 至 <code>exect</code> 的区域，起始虚拟地址设定为 <code>KERNBASE</code></li>
<li>关联trampoline</li>
<li>从最高虚拟地址往下，为每个进程分配一个内核栈页</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#define TRAMPOLINE (MAXVA - PGSIZE)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define KERNBASE 0x80000000L
</span></span></span><span class="line"><span class="cl"><span class="cp">#define PHYSTOP (KERNBASE + 128*1024*1024)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">char</span> <span class="n">trampoline</span><span class="p">[];</span> <span class="c1">// trampoline.S
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="kt">char</span> <span class="n">etext</span><span class="p">[];</span>  <span class="c1">// kernel.ld sets this to end of kernel code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Initialize the one kernel_pagetable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">kvminit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">kernel_pagetable</span> <span class="o">=</span> <span class="n">kvmmake</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Make a direct-map page table for the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pagetable_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">kvmmake</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">pagetable_t</span> <span class="n">kpgtbl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">kpgtbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">pagetable_t</span><span class="p">)</span> <span class="n">kalloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">memset</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// uart registers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">UART0</span><span class="p">,</span> <span class="n">UART0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// virtio mmio disk interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">VIRTIO0</span><span class="p">,</span> <span class="n">VIRTIO0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// PLIC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">PLIC</span><span class="p">,</span> <span class="n">PLIC</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map kernel text executable and read-only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map kernel data and the physical RAM we&#39;ll make use of.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="n">PHYSTOP</span><span class="o">-</span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map the trampoline for trap entry/exit to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the highest virtual address in the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">TRAMPOLINE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">trampoline</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map kernel stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">proc_mapstacks</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">kpgtbl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>进程处于内核态时栈的分配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// map kernel stacks beneath the trampoline,
</span></span></span><span class="line"><span class="cl"><span class="c1">// each surrounded by invalid guard pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Allocate a page for each process&#39;s kernel stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Map it high in memory, followed by an invalid
</span></span></span><span class="line"><span class="cl"><span class="c1">// guard page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">proc_mapstacks</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">kpgtbl</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">panic</span><span class="p">(</span><span class="s">&#34;kalloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">KSTACK</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">proc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="xv6进程在用户态下虚拟内存空间分布">xv6进程在用户态下，虚拟内存空间分布<a hidden class="anchor" aria-hidden="true" href="#xv6进程在用户态下虚拟内存空间分布">#</a></h2>
<ul>
<li>text：代码区</li>
<li>data：静态数据区</li>
<li>stack：栈</li>
<li>guard page：位于栈和数据区之间，避免栈溢出越界覆盖数据区</li>
<li>heap：堆</li>
<li>trampframe：进程信息</li>
<li>trampoline：存储切换内核态的指令</li>
</ul>
<!-- raw HTML omitted -->
<p>xv6创建用户进程，内存初始化：创建进程三级页表 + 加载程序</p>
<p>① 创建进程三级页表</p>
<ul>
<li>申请一个空页表</li>
<li>将trampoline、trapframe的物理页表地址与虚拟地址联系起来
<ul>
<li>trapframe页表之前已经申请了，其首地址为p-&gt;trapframe</li>
<li>trampoline一段声明在trampoline.S中的程序，用于实现内核用户态之间的切换。所有进程的trampoline虚拟地址都映射到同一物理地址。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TRAMPOLINE (MAXVA - PGSIZE)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TRAPFRAME (TRAMPOLINE - PGSIZE)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">char</span> <span class="n">trampoline</span><span class="p">[];</span> <span class="c1">// trampoline.S
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Create a user page table for a given process,
</span></span></span><span class="line"><span class="cl"><span class="c1">// with no user memory, but with trampoline pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">pagetable_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">proc_pagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pagetable_t</span> <span class="n">pagetable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// An empty page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pagetable</span> <span class="o">=</span> <span class="nf">uvmcreate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">pagetable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map the trampoline code (for system call return)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// at the highest user virtual address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// only the supervisor uses it, on the way
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to/from user space, so not PTE_U.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="nf">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">TRAMPOLINE</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">trampoline</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">uvmfree</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map the trapframe just below TRAMPOLINE, for trampoline.S.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="nf">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">TRAPFRAME</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="n">uint64</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">),</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">uvmunmap</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">TRAMPOLINE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">uvmfree</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">pagetable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>② 加载进程程序</p>
<ul>
<li>src指针指向用户空间中存放进程代码的位置</li>
<li>用户进程统一从虚拟地址0映射程序，物理地址不是src，而是内核程序申请用于存放程序的页的物理地址</li>
<li>需要设置PTE_U=1，允许进程处于用户态时访问</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">uvminit</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">uint</span> <span class="n">sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">PGSIZE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;inituvm: more than a page&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mem</span> <span class="o">=</span> <span class="nf">kalloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">,</span> <span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_X</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">memmove</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>清除用户内存：</p>
<ul>
<li>消除关联，否则会报错panic(&ldquo;freewalk: leaf&rdquo;);</li>
<li>递归清除页表：对于每个页表，先清除页表项为0，再回首页表</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">freewalk</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// this PTE points to a lower-level page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">uint64</span> <span class="n">child</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">freewalk</span><span class="p">((</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">panic</span><span class="p">(</span><span class="s">&#34;freewalk: leaf&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pagetable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Free user memory pages,
</span></span></span><span class="line"><span class="cl"><span class="c1">// then free page-table pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">uvmfree</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">uvmunmap</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span><span class="o">/</span><span class="n">PGSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">freewalk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="内存物理空间管理器">内存物理空间管理器<a hidden class="anchor" aria-hidden="true" href="#内存物理空间管理器">#</a></h2>
<p><strong>kernel/kalloc.h</strong></p>
<p>分配的地址为[内核空间~PHYSTOP]</p>
<p>以一个页表为单位进行分配/回收</p>
<p>通过链表追踪可用的空闲页表地址，allocator只有一个kmem内存空间，链表上的其他结点信息均存储在空闲页表的首部</p>
<h2 id="内存管理程序">内存管理程序<a hidden class="anchor" aria-hidden="true" href="#内存管理程序">#</a></h2>
<p>映射虚拟地址➡物理地址mappages：自起始虚拟地址 <code>va</code> 起，连续 <code>pa</code> 字节的虚拟地址空间映射至起始于 <code>pa</code> 的物理地址空间</p>
<ul>
<li>不是直接从va算起，需计算起始地址对应页的首地址</li>
<li>循环处理每一页，包括检查该页是否已经被申请，设置对应的物理地址（函数参数）、有效位、权限</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">mappages</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">size</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">a</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">panic</span><span class="p">(</span><span class="s">&#34;mappages: size&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">a</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">last</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">panic</span><span class="p">(</span><span class="s">&#34;mappages: remap&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">PA2PTE</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pa</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>给定虚拟地址➡物理地址 walk：在给定的三级页表中，查找虚拟地址 <code>va</code> 对应的页表项</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">pte_t</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">walk</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">va</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">panic</span><span class="p">(</span><span class="s">&#34;walk&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">PX</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">va</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pagetable</span> <span class="o">=</span> <span class="p">(</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">alloc</span> <span class="o">||</span> <span class="p">(</span><span class="n">pagetable</span> <span class="o">=</span> <span class="p">(</span><span class="n">pde_t</span><span class="o">*</span><span class="p">)</span><span class="n">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">memset</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">PA2PTE</span><span class="p">(</span><span class="n">pagetable</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">PX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">va</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="1-speed-up-system-calls">1 Speed up system calls<a hidden class="anchor" aria-hidden="true" href="#1-speed-up-system-calls">#</a></h2>
<h3 id="题目">题目<a hidden class="anchor" aria-hidden="true" href="#题目">#</a></h3>
<p>创建进程时，在虚拟地址<code>USYSCALL</code>映射一个只读页面。在此页面的开头，存储一个结构体<code>usyscall</code>（也在<code>memlayout.h</code>中定义），并以当前进程PID初始化该结构体。</p>
<h3 id="思路">思路<a hidden class="anchor" aria-hidden="true" href="#思路">#</a></h3>
<ol>
<li>在<code>proc.h</code>中增加<code>struct usyscall *usyscall</code>字段，用于存储共享页指针</li>
<li><code>allocproc()</code>（进程创建时向内存申请空闲页）：申请新页，并将该页的指针地址存入<code>p-&gt;usyscall</code>字段中</li>
<li><code>proc_pagetable()</code>（初始化进程虚拟内存空间，即申请用户内存空间的一级页表并实现已申请的特殊页的映射）：map USYSCALL页的物理地址和<code>USYSCALL</code>虚拟地址，形成的页表项添加到当前函数的页表中，设置该页权限为只读+<strong>允许用户访问</strong>，<!-- raw HTML omitted -->map失败要unmap之前成功map的页<!-- raw HTML omitted --></li>
<li><code>proc_freepagetable()</code>（释放用户内存空间的二级页表）：<!-- raw HTML omitted -->unmap usyscall页<!-- raw HTML omitted --></li>
<li><code>freeproc()</code>（进程销毁时清空该进程所占资源）：使用<code>kfree()</code>清除<code>p-&gt;usyscall</code>指向的物理页，对应的p-&gt;usyscall设置为0</li>
</ol>
<blockquote>
<p>报错：【panic：freewalk：leaf】</p>
<p>定位：只有uvmfree调用了freewalk；多处调用uvmfree之前使用uvunmap unmap页表项</p>
<p>释放页表之前，要先unmap页表的对应关系，即清除pte中的PTE_V为0：</p>
<ul>
<li>三、二级页表：(pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</li>
<li>一级页表：pte &amp; PTE_V == 1</li>
</ul>
<p>freewalk在释放一级页表时，如果一级页表项是有效的（pte &amp; PTE_V == 1），则发生上述错误</p>
<p>所以调用freewalk之前，需要unmap一级页表页表项</p>
</blockquote>
<h3 id="源码">源码<a hidden class="anchor" aria-hidden="true" href="#源码">#</a></h3>
<p><strong>kernel/proc.h</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// struct proc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">usyscall</span> <span class="o">*</span><span class="n">usyscall</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>kernel/proc.c</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">allocproc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Allocate a USYSCALL page for kernel to share with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">usyscallpage</span> <span class="o">=</span> <span class="p">(</span><span class="kt">pagetable_t</span><span class="p">)</span><span class="nf">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">freeproc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">usyscall</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">proc_pagetable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// map the usyscall just below USYSCALL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nf">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">USYSCALL</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="n">uint64</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">usyscall</span><span class="p">),</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">uvmunmap</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">USYSCALL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">uvmfree</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">freeproc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">usyscall</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">usyscall</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">usyscall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// proc_freepagetable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmunmap</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">USYSCALL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2-print-a-page-table">2 Print a page table​​<a hidden class="anchor" aria-hidden="true" href="#2-print-a-page-table">#</a></h2>
<h3 id="题目-1">题目<a hidden class="anchor" aria-hidden="true" href="#题目-1">#</a></h3>
<p>定义<code>vmprint(pagetable_t)</code>函数，打印<code>pagetable_t</code>页表及子页表中所有合法页表项的内容</p>
<h3 id="思路-1">思路<a hidden class="anchor" aria-hidden="true" href="#思路-1">#</a></h3>
<p>定义两个函数：<code>vmprint</code>、<code>vmsprint</code></p>
<p><code>vmsprint(pagetable_t)</code></p>
<ol>
<li>遍历<code>pagetable_t</code>页表所有页表项</li>
<li>若当前页表项<code>pte_t</code>是合法的，打印相关信息</li>
<li>版本一：若当前页表项合法并且不存在RWX在权限，说明该页表项所指向的页表不是零级页表，递归调用<code>vmsprint</code>函数，打印当前页表项所指向的页表</li>
<li>版本二：无论当前页表项是不是指向零级页表，都进行递归，但是<code>vmsprint</code>函数需要增加一个<code>level</code>c参数，表示当前页表是第几级页表。若是第三级，表示当前页表是零级页表，退出，不需要进行递归。</li>
</ol>
<h3 id="源码-1">源码<a hidden class="anchor" aria-hidden="true" href="#源码-1">#</a></h3>
<p><strong>kernel/vm.c</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">vmprint</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;page table %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pagetable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">vmsprint</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> 
</span></span><span class="line"><span class="cl"><span class="nf">vmsprint</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">  <span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pte</span> <span class="o">=</span> <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;..&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34; ..&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">child</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d: pte %p pa %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">vmsprint</span><span class="p">((</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>C语言中，使用<code>%p</code>占位符打印指针变量的值，也就是虚拟地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;the address is %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3-detecting-which-pages-have-been-accessed">3 Detecting which pages have been accessed​<a hidden class="anchor" aria-hidden="true" href="#3-detecting-which-pages-have-been-accessed">#</a></h2>
<h3 id="题目-2">题目<a hidden class="anchor" aria-hidden="true" href="#题目-2">#</a></h3>
<p>实现<code>pgaccess</code>系统调用，汇报哪些page在上次该系统调用之前被修改或访问过。包含以下三个参数：</p>
<ul>
<li>va：要检查的第一个user page的虚拟地址</li>
<li>checknum：待检查页数</li>
<li>dstva：位于用户空间，用于存储结果的缓冲区的虚拟地址（最低位对应第一页）</li>
</ul>
<h3 id="思路-2">思路<a hidden class="anchor" aria-hidden="true" href="#思路-2">#</a></h3>
<p>获取<code>pgaccess()</code>系统调用的参数</p>
<p>对于每一待检查的页：</p>
<ol>
<li>计算该页虚拟首地址va</li>
<li>基于walk函数，获取虚拟地址va在一级页表中的页表项<!-- raw HTML omitted -->（第29行代码错误，未获取最后一次PTE）<!-- raw HTML omitted --></li>
<li>依据页表项的具体数值，对<code>PTE_A</code>进行检查。若<code>PTE_A</code>已被置位，就把该页的标识符写入掩码（mask）里。同时，为避免对后续检查产生干扰，需清除<code>PTE_A</code>标记</li>
<li>使用<code>copyout()</code>将结果写回用户空间</li>
</ol>
<h3 id="源码-2">源码<a hidden class="anchor" aria-hidden="true" href="#源码-2">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">uint64</span>
</span></span><span class="line"><span class="cl"><span class="nf">sys_pgaccess</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">uint64</span> <span class="n">va</span><span class="p">,</span> <span class="n">dstva</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">checknum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">va</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">va</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">panic</span><span class="p">(</span><span class="s">&#34;pgaccess virtual address no more than MAXVA&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">checknum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">checknum</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="n">checknum</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dstva</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="nc">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">checknum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">pagetable_t</span> <span class="n">pagetable</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">pte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">PX</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">va</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">			<span class="n">pagetable</span> <span class="o">=</span> <span class="p">(</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">pte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">PX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">va</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_A</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="o">*</span><span class="n">pte</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">PTE_A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">va</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">dstva</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mask</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/os/">OS</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/mit6.s081/lab4-trap/">
    <span class="title">« Prev</span>
    <br>
    <span>Lab4: traps</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/mit6.s081/lab2-system-calls/">
    <span class="title">Next »</span>
    <br>
    <span>Lab2: system calls</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">momo blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
