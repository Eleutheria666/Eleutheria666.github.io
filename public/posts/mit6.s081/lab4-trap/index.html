<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lab4: traps | momo blog</title>
<meta name="keywords" content="OS">
<meta name="description" content="Lab链接：Lab: Traps
Lab源码：momo/MIT-6S081/traps - Gitee.com
用户态切换为内核态发生在以下情形：
系统调用 软件运行错误：page fault 设备发出中断 用户内核态的切换，要让硬件从适合用户程序运行的状态转化为适合内核程序运行的状态，包括：
保存32个用户寄存器：内核会使用寄存器，用户程序在寄存器中的值不能被破坏 保存程序计数器：内核程序执行完毕后能够从用户程序中断的位置继续执行 改为supervisor mode：在内核中需要执行特权指令 SATP寄存器从user page table改为kernel page table 堆栈寄存器指向内核地址 相比用户态，内核态增加了以下权限：
读写控制寄存器 使用PTE_U为0的页表：PTE_U设置为1用户态可使用 trapoline页表在用户和内核页表虚拟地址一致，映射的都是同一个物理页
trapframe用于保存进程在用户态的相关数据，而context用于保存进程在内核态相关数据
用户态➡内核态 用户进程调用fork系统调用，实际执行如下指令：
1 2 3 4 5 .global fork fork: li a7, SYS_fork ecall ret 向a7寄存器写入系统调用编号 执行ecall指令，该指令在硬件层面完成： 切换为supervisor mode 进入中断处理程序：PC➡SEPC，STVEC➡PC（STVEC事先保存了中断处理程序uservec的地址） 此时进入中断处理程序uservec（此时未切换page table，虽进入内核态但仍使用用户态的页表）
保存用户态通用寄存器，用于中断后恢复上下文：sscratch 寄存器事先存储了p-&gt;trapframe ，交换 a0 和 sscratch 的值，使得 a0 指向进程trapframe的首地址 加载内核态上下文：栈指针、内核页表、从 TRAPFRAME 中读取 usertrap() 函数的地址，并将其加载到 t0 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 .">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/mit6.s081/lab4-trap/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8f541c169a12d0d6bb704527bb78f6481fb4f5a39b7171fc16fab8c03ae6b1bd.css" integrity="sha256-j1QcFpoS0Na7cEUnu3j2SB&#43;09aObcXH8Fvq4wDrmsb0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/mit6.s081/lab4-trap/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Lab4: traps" />
<meta property="og:description" content="Lab链接：Lab: Traps
Lab源码：momo/MIT-6S081/traps - Gitee.com
用户态切换为内核态发生在以下情形：
系统调用 软件运行错误：page fault 设备发出中断 用户内核态的切换，要让硬件从适合用户程序运行的状态转化为适合内核程序运行的状态，包括：
保存32个用户寄存器：内核会使用寄存器，用户程序在寄存器中的值不能被破坏 保存程序计数器：内核程序执行完毕后能够从用户程序中断的位置继续执行 改为supervisor mode：在内核中需要执行特权指令 SATP寄存器从user page table改为kernel page table 堆栈寄存器指向内核地址 相比用户态，内核态增加了以下权限：
读写控制寄存器 使用PTE_U为0的页表：PTE_U设置为1用户态可使用 trapoline页表在用户和内核页表虚拟地址一致，映射的都是同一个物理页
trapframe用于保存进程在用户态的相关数据，而context用于保存进程在内核态相关数据
用户态➡内核态 用户进程调用fork系统调用，实际执行如下指令：
1 2 3 4 5 .global fork fork: li a7, SYS_fork ecall ret 向a7寄存器写入系统调用编号 执行ecall指令，该指令在硬件层面完成： 切换为supervisor mode 进入中断处理程序：PC➡SEPC，STVEC➡PC（STVEC事先保存了中断处理程序uservec的地址） 此时进入中断处理程序uservec（此时未切换page table，虽进入内核态但仍使用用户态的页表）
保存用户态通用寄存器，用于中断后恢复上下文：sscratch 寄存器事先存储了p-&gt;trapframe ，交换 a0 和 sscratch 的值，使得 a0 指向进程trapframe的首地址 加载内核态上下文：栈指针、内核页表、从 TRAPFRAME 中读取 usertrap() 函数的地址，并将其加载到 t0 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/mit6.s081/lab4-trap/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-09-14T00:00:00+00:00" /><meta property="og:site_name" content="momo blog" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Lab4: traps"/>
<meta name="twitter:description" content="Lab链接：Lab: Traps
Lab源码：momo/MIT-6S081/traps - Gitee.com
用户态切换为内核态发生在以下情形：
系统调用 软件运行错误：page fault 设备发出中断 用户内核态的切换，要让硬件从适合用户程序运行的状态转化为适合内核程序运行的状态，包括：
保存32个用户寄存器：内核会使用寄存器，用户程序在寄存器中的值不能被破坏 保存程序计数器：内核程序执行完毕后能够从用户程序中断的位置继续执行 改为supervisor mode：在内核中需要执行特权指令 SATP寄存器从user page table改为kernel page table 堆栈寄存器指向内核地址 相比用户态，内核态增加了以下权限：
读写控制寄存器 使用PTE_U为0的页表：PTE_U设置为1用户态可使用 trapoline页表在用户和内核页表虚拟地址一致，映射的都是同一个物理页
trapframe用于保存进程在用户态的相关数据，而context用于保存进程在内核态相关数据
用户态➡内核态 用户进程调用fork系统调用，实际执行如下指令：
1 2 3 4 5 .global fork fork: li a7, SYS_fork ecall ret 向a7寄存器写入系统调用编号 执行ecall指令，该指令在硬件层面完成： 切换为supervisor mode 进入中断处理程序：PC➡SEPC，STVEC➡PC（STVEC事先保存了中断处理程序uservec的地址） 此时进入中断处理程序uservec（此时未切换page table，虽进入内核态但仍使用用户态的页表）
保存用户态通用寄存器，用于中断后恢复上下文：sscratch 寄存器事先存储了p-&gt;trapframe ，交换 a0 和 sscratch 的值，使得 a0 指向进程trapframe的首地址 加载内核态上下文：栈指针、内核页表、从 TRAPFRAME 中读取 usertrap() 函数的地址，并将其加载到 t0 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MIT6.S081-Lab",
      "item": "http://localhost:1313/posts/mit6.s081/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Lab4: traps",
      "item": "http://localhost:1313/posts/mit6.s081/lab4-trap/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab4: traps",
  "name": "Lab4: traps",
  "description": "Lab链接：Lab: Traps\nLab源码：momo/MIT-6S081/traps - Gitee.com\n用户态切换为内核态发生在以下情形：\n系统调用 软件运行错误：page fault 设备发出中断 用户内核态的切换，要让硬件从适合用户程序运行的状态转化为适合内核程序运行的状态，包括：\n保存32个用户寄存器：内核会使用寄存器，用户程序在寄存器中的值不能被破坏 保存程序计数器：内核程序执行完毕后能够从用户程序中断的位置继续执行 改为supervisor mode：在内核中需要执行特权指令 SATP寄存器从user page table改为kernel page table 堆栈寄存器指向内核地址 相比用户态，内核态增加了以下权限：\n读写控制寄存器 使用PTE_U为0的页表：PTE_U设置为1用户态可使用 trapoline页表在用户和内核页表虚拟地址一致，映射的都是同一个物理页\ntrapframe用于保存进程在用户态的相关数据，而context用于保存进程在内核态相关数据\n用户态➡内核态 用户进程调用fork系统调用，实际执行如下指令：\n1 2 3 4 5 .global fork fork: li a7, SYS_fork ecall ret 向a7寄存器写入系统调用编号 执行ecall指令，该指令在硬件层面完成： 切换为supervisor mode 进入中断处理程序：PC➡SEPC，STVEC➡PC（STVEC事先保存了中断处理程序uservec的地址） 此时进入中断处理程序uservec（此时未切换page table，虽进入内核态但仍使用用户态的页表）\n保存用户态通用寄存器，用于中断后恢复上下文：sscratch 寄存器事先存储了p-\u0026gt;trapframe ，交换 a0 和 sscratch 的值，使得 a0 指向进程trapframe的首地址 加载内核态上下文：栈指针、内核页表、从 TRAPFRAME 中读取 usertrap() 函数的地址，并将其加载到 t0 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 .",
  "keywords": [
    "OS"
  ],
  "articleBody": "Lab链接：Lab: Traps\nLab源码：momo/MIT-6S081/traps - Gitee.com\n用户态切换为内核态发生在以下情形：\n系统调用 软件运行错误：page fault 设备发出中断 用户内核态的切换，要让硬件从适合用户程序运行的状态转化为适合内核程序运行的状态，包括：\n保存32个用户寄存器：内核会使用寄存器，用户程序在寄存器中的值不能被破坏 保存程序计数器：内核程序执行完毕后能够从用户程序中断的位置继续执行 改为supervisor mode：在内核中需要执行特权指令 SATP寄存器从user page table改为kernel page table 堆栈寄存器指向内核地址 相比用户态，内核态增加了以下权限：\n读写控制寄存器 使用PTE_U为0的页表：PTE_U设置为1用户态可使用 trapoline页表在用户和内核页表虚拟地址一致，映射的都是同一个物理页\ntrapframe用于保存进程在用户态的相关数据，而context用于保存进程在内核态相关数据\n用户态➡内核态 用户进程调用fork系统调用，实际执行如下指令：\n1 2 3 4 5 .global fork fork: li a7, SYS_fork ecall ret 向a7寄存器写入系统调用编号 执行ecall指令，该指令在硬件层面完成： 切换为supervisor mode 进入中断处理程序：PC➡SEPC，STVEC➡PC（STVEC事先保存了中断处理程序uservec的地址） 此时进入中断处理程序uservec（此时未切换page table，虽进入内核态但仍使用用户态的页表）\n保存用户态通用寄存器，用于中断后恢复上下文：sscratch 寄存器事先存储了p-\u003etrapframe ，交换 a0 和 sscratch 的值，使得 a0 指向进程trapframe的首地址 加载内核态上下文：栈指针、内核页表、从 TRAPFRAME 中读取 usertrap() 函数的地址，并将其加载到 t0 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 .globl uservec uservec: # # trap.c sets stvec to point here, so # traps from user space start here, # in supervisor mode, but with a # user page table. # # sscratch points to where the process's p-\u003etrapframe is # mapped into user space, at TRAPFRAME. # # swap a0 and sscratch, so that a0 is TRAPFRAME csrrw a0, sscratch, a0 # save the user registers in TRAPFRAME sd ra, 40(a0) sd sp, 48(a0) sd gp, 56(a0) sd tp, 64(a0) sd t0, 72(a0) sd t1, 80(a0) # ..... # save the user a0 in p-\u003etrapframe-\u003ea0 csrr t0, sscratch sd t0, 112(a0) # restore kernel stack pointer from p-\u003etrapframe-\u003ekernel_sp ld sp, 8(a0) # make tp hold the current hartid, from p-\u003etrapframe-\u003ekernel_hartid ld tp, 32(a0) # restore kernel page table from p-\u003etrapframe-\u003ekernel_satp ld t1, 0(a0) # load the address of usertrap(), p-\u003etrapframe-\u003ekernel_trap ld t0, 16(a0) csrw satp, t1 sfence.vma zero, zero # jump to usertrap(), which does not return jr t0 此时进入中断处理程序的第二部分\ntrap.c中处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // // handle an interrupt, exception, or system call from user space. // called from trampoline.S // void usertrap(void) { int which_dev = 0; if((r_sstatus() \u0026 SSTATUS_SPP) != 0) panic(\"usertrap: not from user mode\"); // send interrupts and exceptions to kerneltrap(), // since we're now in the kernel. w_stvec((uint64)kernelvec); struct proc *p = myproc(); // save user program counter. p-\u003etrapframe-\u003eepc = r_sepc(); if(r_scause() == 8){ // system call if(p-\u003ekilled) exit(-1); // sepc points to the ecall instruction, // but we want to return to the next instruction. p-\u003etrapframe-\u003eepc += 4; // an interrupt will change sstatus \u0026c registers, // so don't enable until done with those registers. intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ if(which_dev == 2) { // pass if Set time interval task if(p-\u003ealarminterval != 0) { // Time interval tick pass if(--p-\u003etickleft \u003c= 0) { if(p-\u003edoing_alarm == 0) { p-\u003etickleft = p-\u003ealarminterval; *p-\u003ealarmtrapframe = *p-\u003etrapframe; p-\u003etrapframe-\u003eepc = (uint64)p-\u003ealarmhandler; p-\u003edoing_alarm = 1; } } } // give up the CPU if this is a timer interrupt. yield(); } } else { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); p-\u003ekilled = 1; } if(p-\u003ekilled) exit(-1); usertrapret(); } 内核态➡用户态 STVEC寄存器：保存uservec函数的地址，为ecall指令跳转 SSCRATCH寄存器：保存trapframe page的虚拟地址 trapframe的kernel_sp字段：存储进程的kernel stack的最顶端，下次存储在SP寄存器中 trapframe的kernel_satp字段：存储内核页表的物理地址，下次存储在SATP寄存器中 trapframe的kernel_trap字段：转入trap处理的内核C函数usertrap()的地址，下次直接跳转至该函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 .globl userret userret: # userret(TRAPFRAME, pagetable) # switch from kernel to user. # usertrapret() calls here. # a0: TRAPFRAME, in user page table. # a1: user page table, for satp. # switch to the user page table. csrw satp, a1 sfence.vma zero, zero # put the saved user a0 in sscratch, so we # can swap it with our a0 (TRAPFRAME) in the last step. ld t0, 112(a0) csrw sscratch, t0 # restore all but a0 from TRAPFRAME ld ra, 40(a0) ld sp, 48(a0) ld gp, 56(a0) ld tp, 64(a0) ld t0, 72(a0) ld t1, 80(a0) ld t2, 88(a0) # ... # restore user a0, and save TRAPFRAME in sscratch csrrw a0, sscratch, a0 # return to user mode and user pc. # usertrapret() set up sstatus and sepc. sret 1 RISC-V assembly 使用make fs.img命令生成call.c文件的汇编文件call.asm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int g(int x) { 0:\t1141 addi\tsp,sp,-16 2:\te422 sd\ts0,8(sp) 4:\t0800 addi\ts0,sp,16 return x+3; } 6:\t250d addiw\ta0,a0,3 8:\t6422 ld\ts0,8(sp) a:\t0141 addi\tsp,sp,16 c:\t8082 ret 000000000000000e : int f(int x) { e:\t1141 addi\tsp,sp,-16 10:\te422 sd\ts0,8(sp) 12:\t0800 addi\ts0,sp,16 return g(x); } 14:\t250d addiw\ta0,a0,3 16:\t6422 ld\ts0,8(sp) 18:\t0141 addi\tsp,sp,16 1a:\t8082 ret 000000000000001c : void main(void) { 1c:\t1141 addi\tsp,sp,-16 1e:\te406 sd\tra,8(sp) 20:\te022 sd\ts0,0(sp) 22:\t0800 addi\ts0,sp,16 printf(\"%d %d\\n\", f(8)+1, 13); 24:\t4635 li\ta2,13 26:\t45b1 li\ta1,12 28:\t00000517 auipc\ta0,0x0 2c:\t7b850513 addi\ta0,a0,1976 # 7e0 30:\t00000097 auipc\tra,0x0 34:\t608080e7 jalr\t1544(ra) # 638 exit(0); 38:\t4501 li\ta0,0 3a:\t00000097 auipc\tra,0x0 3e:\t276080e7 jalr\t630(ra) # 2b0 回答以下问题：\nWhich registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?\nRISC - V 架构，函数调用者在调用前，将参数按顺序依次存储在 a0 - a7 寄存器中，然后再调用函数。\n第24行，li a2 13指令把立即数13存入寄存器a2，a2存入参数13，a1存入f(8)+1的结果，a0存入格式字符串的地址。\nWhere is the call to function f in the assembly code for main? Where is the call to g?\n第26行， li a1 12指令表明main函数并未调用函数f，编译器直接计算f(8)+1的结果并存入寄存器a1。\nAt what address is the function printf located?\n第34行，注释指出prinf函数位于用户空间虚拟地址0x638处。\nWhat value is in the register ra just after the jalr to printf in main?\n第30行，auipc ra, 0x0 把当前PC值高 20 位加载到 ra 寄存器，jalr 1544(ra) 跳转到 printf 函数，同时把下一条指令（地址为 0x38）的地址保存到 ra 寄存器。所以，在执行完 jalr 指令跳转到 printf 函数后，ra 寄存器的值是 0x38。\n2 Backtrace 题目 实现backtrace()函数：遍历当前程序的调用栈，按照函数调用的先后顺序，从当前时刻起，逆向打印每个栈帧中的返回地址\n运行bttest，该程序调用sys_sleep，sys_sleep()调用backtrace()打印当前堆栈上的函数调用列表。打印的结果如下：\n1 2 3 4 backtrace: 0x0000000080002cda 0x0000000080002bb6 0x0000000080002898 退出qemu，执行addr2line -e kernel/kernel命令并输入上述结果，得到地址对应的函数名和所在文件\n在终端中输入 addr2line -e kernel/kernel 命令，并输入之前获取到的地址信息。该命令解析输入的地址，得到其所处在哪个文件中的哪个位置，为调试进一步提供关键线索。\n1 2 3 4 5 6 7 8 9 $ addr2line -e kernel/kernel 0x0000000080002de2 0x0000000080002f4a 0x0000000080002bfc Ctrl-D # 上述命令执行结果： kernel/sysproc.c:74 kernel/syscall.c:224 kernel/trap.c:85 思路 在kernel/riscv.c文件中添加用于读取当前栈顶寄存器值的函数r_fp\n使用PGROUNDDOWN()获取栈所在页的顶部地址\n下图展现了xv6栈的结构，栈帧从内存较高地址处起始，随着函数调用朝内存较低方向生成栈帧。\n在遍历当前程序内核栈的过程中，针对每一个栈帧，打印该栈帧的函数地址，即 “返回地址（return address）”。同时，借助 “to prev frame（指向前一个栈帧）” 所指示的信息，获取调用该函数的栈帧的地址，进而推进栈的遍历流程 。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void backtrace(void) { printf(\"backtrace\\n\"); // get current working function's frame pointer uint64 *fp = (uint64*)r_fp(); uint64 limit = PGROUNDUP((uint64)fp); while((uint64)fp \u003c limit) { printf(\"%p\\n\", *(fp-1)); fp = (uint64*)(*(fp-2)); } } 指针所指向的地址虽然可表示为 64 位整数，但要获取指针所指向的数据内容，fp 的类型理应定义为 uint64*，而非 uint64。这是因为只有 uint64* 类型才能正确解引用，从而访问到目标数据。\n当 fp 被定义为 uint64 类型的指针时，对该指针执行 -1 操作，实际上是在内存地址上向前移动了 8 byte。这是由于在 64 位系统中，uint64 类型数据占据 8 个字节，指针运算会根据其所指向的数据类型大小来调整偏移量 。\n运行结果：\n3 Alarm​​ 题目 思路 源码 ",
  "wordCount" : "1110",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-09-14T00:00:00Z",
  "dateModified": "2024-09-14T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/mit6.s081/lab4-trap/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "momo blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="momo blog (Alt + H)">momo blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/mit6.s081/">MIT6.S081-Lab</a></div>
    <h1 class="post-title entry-hint-parent">
      Lab4: traps
    </h1>
    <div class="post-meta"><span title='2024-09-14 00:00:00 +0000 UTC'>September 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1110 words

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e6%80%81%e5%86%85%e6%a0%b8%e6%80%81" aria-label="用户态➡内核态">用户态➡内核态</a></li>
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e6%80%81%e7%94%a8%e6%88%b7%e6%80%81" aria-label="内核态➡用户态">内核态➡用户态</a></li>
                <li>
                    <a href="#1-risc-v-assembly" aria-label="1 RISC-V assembly">1 RISC-V assembly</a></li>
                <li>
                    <a href="#2-backtrace" aria-label="2 Backtrace">2 Backtrace</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae" aria-label="题目">题目</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af" aria-label="思路">思路</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81" aria-label="源码">源码</a></li></ul>
                </li>
                <li>
                    <a href="#3-alarm" aria-label="3 Alarm​​">3 Alarm​​</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae-1" aria-label="题目">题目</a></li>
                <li>
                    <a href="#%e6%80%9d%e8%b7%af-1" aria-label="思路">思路</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81-1" aria-label="源码">源码</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Lab链接：<a href="https://pdos.csail.mit.edu/6.S081/2021/labs/traps.html">Lab: Traps</a></p>
<p>Lab源码：<a href="https://gitee.com/Eleutheria666/mit-6s081/tree/traps/">momo/MIT-6S081/traps - Gitee.com</a></p>
<p>用户态切换为内核态发生在以下<strong>情形</strong>：</p>
<ul>
<li>系统调用</li>
<li>软件运行错误：page fault</li>
<li>设备发出中断</li>
</ul>
<p>用户内核态的切换，要让<strong>硬件从适合用户程序运行的状态转化为适合内核程序运行的状态</strong>，包括：</p>
<ol>
<li>保存32个用户寄存器：内核会使用寄存器，用户程序在寄存器中的值不能被破坏</li>
<li>保存程序计数器：内核程序执行完毕后能够从用户程序中断的位置继续执行</li>
<li>改为supervisor mode：在内核中需要执行特权指令</li>
<li>SATP寄存器从user page table改为kernel page table</li>
<li>堆栈寄存器指向内核地址</li>
</ol>
<p>相比用户态，<strong>内核态增加了以下权限</strong>：</p>
<ol>
<li>读写控制寄存器</li>
<li>使用PTE_U为0的页表：PTE_U设置为1用户态可使用</li>
</ol>
<p><code>trapoline</code>页表在用户和内核页表虚拟地址一致，映射的都是同一个物理页</p>
<p><code>trapframe</code>用于保存进程在用户态的相关数据，而context用于保存进程在内核态相关数据</p>
<h2 id="用户态内核态">用户态➡内核态<a hidden class="anchor" aria-hidden="true" href="#用户态内核态">#</a></h2>
<p>用户进程调用<code>fork</code>系统调用，实际执行如下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.global fork
</span></span><span class="line"><span class="cl">fork:
</span></span><span class="line"><span class="cl"> li a7, SYS_fork
</span></span><span class="line"><span class="cl"> ecall
</span></span><span class="line"><span class="cl"> ret
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>向a7寄存器写入系统调用编号</li>
<li>执行ecall指令，该指令在硬件层面完成：</li>
</ol>
<ul>
<li>切换为supervisor mode</li>
<li>进入中断处理程序：PC➡SEPC，STVEC➡PC（STVEC事先保存了中断处理程序uservec的地址）</li>
</ul>
<p>此时进入中断处理程序uservec（此时未切换page table，虽进入内核态但仍使用用户态的页表）</p>
<ol>
<li>保存用户态通用寄存器，用于中断后恢复上下文：<code>sscratch</code> 寄存器事先存储了<code>p-&gt;trapframe</code> ，交换 <code>a0</code> 和 <code>sscratch</code> 的值，使得 <code>a0</code> 指向进程trapframe的首地址</li>
<li>加载内核态上下文：栈指针、内核页表、从 <code>TRAPFRAME</code> 中读取 <code>usertrap()</code> 函数的地址，并将其加载到 <code>t0</code> 寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">.</span><span class="n">globl</span> <span class="n">uservec</span>
</span></span><span class="line"><span class="cl"><span class="n">uservec</span><span class="p">:</span>    
</span></span><span class="line"><span class="cl">	<span class="c1">#</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># trap.c sets stvec to point here, so</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># traps from user space start here,</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># in supervisor mode, but with a</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># user page table.</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># sscratch points to where the process&#39;s p-&gt;trapframe is</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># mapped into user space, at TRAPFRAME.</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">		<span class="c1"># swap a0 and sscratch, so that a0 is TRAPFRAME</span>
</span></span><span class="line"><span class="cl">        <span class="n">csrrw</span> <span class="n">a0</span><span class="p">,</span> <span class="n">sscratch</span><span class="p">,</span> <span class="n">a0</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># save the user registers in TRAPFRAME</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">ra</span><span class="p">,</span> <span class="mi">40</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">48</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">gp</span><span class="p">,</span> <span class="mi">56</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">tp</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">72</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">t1</span><span class="p">,</span> <span class="mi">80</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># .....</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># save the user a0 in p-&gt;trapframe-&gt;a0</span>
</span></span><span class="line"><span class="cl">        <span class="n">csrr</span> <span class="n">t0</span><span class="p">,</span> <span class="n">sscratch</span>
</span></span><span class="line"><span class="cl">        <span class="n">sd</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">112</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span>
</span></span><span class="line"><span class="cl">        <span class="n">ld</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span>
</span></span><span class="line"><span class="cl">        <span class="n">ld</span> <span class="n">tp</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span>
</span></span><span class="line"><span class="cl">        <span class="n">ld</span> <span class="n">t1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span>
</span></span><span class="line"><span class="cl">        <span class="n">ld</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">csrw</span> <span class="n">satp</span><span class="p">,</span> <span class="n">t1</span>
</span></span><span class="line"><span class="cl">        <span class="n">sfence</span><span class="o">.</span><span class="n">vma</span> <span class="n">zero</span><span class="p">,</span> <span class="n">zero</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># jump to usertrap(), which does not return</span>
</span></span><span class="line"><span class="cl">        <span class="n">jr</span> <span class="n">t0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时进入中断处理程序的第二部分</p>
<p>trap.c中处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// handle an interrupt, exception, or system call from user space.
</span></span></span><span class="line"><span class="cl"><span class="c1">// called from trampoline.S
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">usertrap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">which_dev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">((</span><span class="nf">r_sstatus</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">SSTATUS_SPP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;usertrap: not from user mode&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// send interrupts and exceptions to kerneltrap(),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// since we&#39;re now in the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">w_stvec</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">kernelvec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// save user program counter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">=</span> <span class="nf">r_sepc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// system call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sepc points to the ecall instruction,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// but we want to return to the next instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// an interrupt will change sstatus &amp;c registers,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so don&#39;t enable until done with those registers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">intr_on</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">syscall</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="nf">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">which_dev</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// pass if Set time interval task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarminterval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Time interval tick pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tickleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">doing_alarm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">tickleft</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">alarminterval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarmtrapframe</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarmhandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">doing_alarm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// give up the CPU if this is a timer interrupt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">yield</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">r_scause</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">r_sepc</span><span class="p">(),</span> <span class="nf">r_stval</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">usertrapret</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="内核态用户态">内核态➡用户态<a hidden class="anchor" aria-hidden="true" href="#内核态用户态">#</a></h2>
<ul>
<li>STVEC寄存器：保存uservec函数的地址，为ecall指令跳转</li>
<li>SSCRATCH寄存器：保存trapframe page的虚拟地址</li>
<li>trapframe的<code>kernel_sp</code>字段：存储进程的kernel stack的最顶端，下次存储在SP寄存器中</li>
<li>trapframe的<code>kernel_satp</code>字段：存储内核页表的物理地址，下次存储在SATP寄存器中</li>
<li>trapframe的<code>kernel_trap</code>字段：转入trap处理的内核C函数<code>usertrap()</code>的地址，下次直接跳转至该函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.globl userret
</span></span><span class="line"><span class="cl">userret:
</span></span><span class="line"><span class="cl">        # userret(TRAPFRAME, pagetable)
</span></span><span class="line"><span class="cl">        # switch from kernel to user.
</span></span><span class="line"><span class="cl">        # usertrapret() calls here.
</span></span><span class="line"><span class="cl">        # a0: TRAPFRAME, in user page table.
</span></span><span class="line"><span class="cl">        # a1: user page table, for satp.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # switch to the user page table.
</span></span><span class="line"><span class="cl">        csrw satp, a1
</span></span><span class="line"><span class="cl">        sfence.vma zero, zero
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # put the saved user a0 in sscratch, so we
</span></span><span class="line"><span class="cl">        # can swap it with our a0 (TRAPFRAME) in the last step.
</span></span><span class="line"><span class="cl">        ld t0, 112(a0)
</span></span><span class="line"><span class="cl">        csrw sscratch, t0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # restore all but a0 from TRAPFRAME
</span></span><span class="line"><span class="cl">        ld ra, 40(a0)
</span></span><span class="line"><span class="cl">        ld sp, 48(a0)
</span></span><span class="line"><span class="cl">        ld gp, 56(a0)
</span></span><span class="line"><span class="cl">        ld tp, 64(a0)
</span></span><span class="line"><span class="cl">        ld t0, 72(a0)
</span></span><span class="line"><span class="cl">        ld t1, 80(a0)
</span></span><span class="line"><span class="cl">        ld t2, 88(a0)
</span></span><span class="line"><span class="cl">        # ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		# restore user a0, and save TRAPFRAME in sscratch
</span></span><span class="line"><span class="cl">        csrrw a0, sscratch, a0
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        # return to user mode and user pc.
</span></span><span class="line"><span class="cl">        # usertrapret() set up sstatus and sepc.
</span></span><span class="line"><span class="cl">        sret
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="1-risc-v-assembly">1 RISC-V assembly<a hidden class="anchor" aria-hidden="true" href="#1-risc-v-assembly">#</a></h2>
<p>使用<code>make fs.img</code>命令生成<code>call.c</code>文件的汇编文件<code>call.asm</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int g(int x) {
</span></span><span class="line"><span class="cl">   0:	1141                	addi	sp,sp,-16
</span></span><span class="line"><span class="cl">   2:	e422                	sd		s0,8(sp)
</span></span><span class="line"><span class="cl">   4:	0800                	addi	s0,sp,16
</span></span><span class="line"><span class="cl">  return x+3;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">   6:	250d                	addiw	a0,a0,3
</span></span><span class="line"><span class="cl">   8:	6422                	ld		s0,8(sp)
</span></span><span class="line"><span class="cl">   a:	0141                	addi	sp,sp,16
</span></span><span class="line"><span class="cl">   c:	8082                	ret
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">000000000000000e &lt;f&gt;:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int f(int x) {
</span></span><span class="line"><span class="cl">   e:	1141                	addi	sp,sp,-16
</span></span><span class="line"><span class="cl">  10:	e422                	sd		s0,8(sp)
</span></span><span class="line"><span class="cl">  12:	0800                	addi	s0,sp,16
</span></span><span class="line"><span class="cl">  return g(x);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">  14:	250d                	addiw	a0,a0,3
</span></span><span class="line"><span class="cl">  16:	6422                	ld		s0,8(sp)
</span></span><span class="line"><span class="cl">  18:	0141                	addi	sp,sp,16
</span></span><span class="line"><span class="cl">  1a:	8082                	ret
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">000000000000001c &lt;main&gt;:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void main(void) {
</span></span><span class="line"><span class="cl">  1c:	1141                	addi	sp,sp,-16
</span></span><span class="line"><span class="cl">  1e:	e406                	sd		ra,8(sp)
</span></span><span class="line"><span class="cl">  20:	e022                	sd		s0,0(sp)
</span></span><span class="line"><span class="cl">  22:	0800                	addi	s0,sp,16
</span></span><span class="line"><span class="cl">  printf(&#34;%d %d\n&#34;, f(8)+1, 13);
</span></span><span class="line"><span class="cl">  24:	4635                	li		a2,13
</span></span><span class="line"><span class="cl">  26:	45b1                	li		a1,12
</span></span><span class="line"><span class="cl">  28:	00000517          		auipc	a0,0x0
</span></span><span class="line"><span class="cl">  2c:	7b850513          		addi	a0,a0,1976 # 7e0 &lt;malloc+0xea&gt;
</span></span><span class="line"><span class="cl">  30:	00000097          		auipc	ra,0x0
</span></span><span class="line"><span class="cl">  34:	608080e7          		jalr	1544(ra) # 638 &lt;printf&gt;
</span></span><span class="line"><span class="cl">  exit(0);
</span></span><span class="line"><span class="cl">  38:	4501                	li		a0,0
</span></span><span class="line"><span class="cl">  3a:	00000097          		auipc	ra,0x0
</span></span><span class="line"><span class="cl">  3e:	276080e7          		jalr	630(ra) # 2b0 &lt;exit&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>回答以下问题：</p>
<ul>
<li>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main&rsquo;s call to <code>printf</code>?</p>
<p>RISC - V 架构，函数调用者在调用前，将参数按顺序依次存储在 <code>a0 - a7</code> 寄存器中，然后再调用函数。</p>
<p>第24行，<code>li a2 13</code>指令把立即数13存入寄存器a2，a2存入参数13，a1存入<code>f(8)+1</code>的结果，a0存入格式字符串<strong>的地址。</strong></p>
</li>
<li>
<p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>?</p>
<p>第26行， <code>li a1 12</code>指令表明main函数并未调用函数f，编译器直接计算<code>f(8)+1</code>的结果并存入寄存器a1。</p>
</li>
<li>
<p>At what address is the function <code>printf</code> located?</p>
<p>第34行，注释指出prinf函数位于<strong>用户空间虚拟地址</strong>0x638处。</p>
</li>
<li>
<p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
<p>第30行，<code>auipc ra, 0x0</code> 把当前PC值高 20 位加载到 <code>ra</code> 寄存器，<code>jalr 1544(ra)</code> 跳转到 <code>printf</code> 函数，同时把下一条指令（地址为 0x38）的地址保存到 <code>ra</code> 寄存器。所以，在执行完 <code>jalr</code> 指令跳转到 <code>printf</code> 函数后，<code>ra</code> 寄存器的值是 0x38。</p>
</li>
</ul>
<h2 id="2-backtrace">2 Backtrace<a hidden class="anchor" aria-hidden="true" href="#2-backtrace">#</a></h2>
<h3 id="题目">题目<a hidden class="anchor" aria-hidden="true" href="#题目">#</a></h3>
<p>实现<code>backtrace()</code>函数：遍历当前程序的调用栈，按照函数调用的先后顺序，从当前时刻起，逆向打印每个栈帧中的返回地址</p>
<p>运行<code>bttest</code>，该程序调用<code>sys_sleep</code>，<code>sys_sleep()</code>调用<code>backtrace()</code>打印当前堆栈上的函数调用列表。打印的结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">backtrace:
</span></span><span class="line"><span class="cl">0x0000000080002cda
</span></span><span class="line"><span class="cl">0x0000000080002bb6
</span></span><span class="line"><span class="cl">0x0000000080002898
</span></span></code></pre></td></tr></table>
</div>
</div><p>退出qemu，执行<code>addr2line -e kernel/kernel</code>命令并输入上述结果，得到地址对应的函数名和所在文件</p>
<p>在终端中输入 <code>addr2line -e kernel/kernel</code> 命令，并输入之前获取到的地址信息。该命令解析输入的地址，得到其所处在哪个文件中的哪个位置，为调试进一步提供关键线索。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ addr2line -e kernel/kernel
</span></span><span class="line"><span class="cl">    0x0000000080002de2
</span></span><span class="line"><span class="cl">    0x0000000080002f4a
</span></span><span class="line"><span class="cl">    0x0000000080002bfc
</span></span><span class="line"><span class="cl">    Ctrl-D
</span></span><span class="line"><span class="cl"><span class="c1"># 上述命令执行结果：</span>
</span></span><span class="line"><span class="cl">kernel/sysproc.c:74
</span></span><span class="line"><span class="cl">kernel/syscall.c:224
</span></span><span class="line"><span class="cl">kernel/trap.c:85
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="思路">思路<a hidden class="anchor" aria-hidden="true" href="#思路">#</a></h3>
<ol>
<li>
<p>在<code>kernel/riscv.c</code>文件中添加用于读取当前栈顶寄存器值的函数<code>r_fp</code></p>
</li>
<li>
<p>使用<code>PGROUNDDOWN()</code>获取栈所在页的顶部地址</p>
</li>
<li>
<p>下图展现了xv6栈的结构，栈帧从内存较高地址处起始，随着函数调用朝内存较低方向生成栈帧。</p>
<p>在遍历当前程序内核栈的过程中，针对每一个栈帧，打印该栈帧的函数地址，即 “返回地址（return address）”。同时，借助 “to prev frame（指向前一个栈帧）” 所指示的信息，获取调用该函数的栈帧的地址，进而推进栈的遍历流程 。</p>
</li>
</ol>
<p><img loading="lazy" src="../../../images/image-20240804214358144.png" alt="image-20240804214358144"  />
</p>
<h3 id="源码">源码<a hidden class="anchor" aria-hidden="true" href="#源码">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span>            
</span></span><span class="line"><span class="cl"><span class="nf">backtrace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;backtrace</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// get current working function&#39;s frame pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint64</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="o">*</span><span class="p">)</span><span class="nf">r_fp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">limit</span> <span class="o">=</span> <span class="nf">PGROUNDUP</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">fp</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">fp</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">fp</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>指针所指向的地址虽然可表示为 64 位整数，但要获取指针所指向的数据内容，<code>fp</code> 的类型理应定义为 <code>uint64*</code>，而非 <code>uint64</code>。这是因为只有 <code>uint64*</code> 类型才能正确解引用，从而访问到目标数据。</p>
<p>当 <code>fp</code> 被定义为 <code>uint64</code> 类型的指针时，对该指针执行 <code>-1</code> 操作，实际上是在内存地址上向前移动了 <code>8 byte</code>。这是由于在 64 位系统中，<code>uint64</code> 类型数据占据 8 个字节，指针运算会根据其所指向的数据类型大小来调整偏移量 。</p>
</blockquote>
<p>运行结果：</p>
<!-- raw HTML omitted -->
<h2 id="3-alarm">3 Alarm​​<a hidden class="anchor" aria-hidden="true" href="#3-alarm">#</a></h2>
<h3 id="题目-1">题目<a hidden class="anchor" aria-hidden="true" href="#题目-1">#</a></h3>
<h3 id="思路-1">思路<a hidden class="anchor" aria-hidden="true" href="#思路-1">#</a></h3>
<h3 id="源码-1">源码<a hidden class="anchor" aria-hidden="true" href="#源码-1">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/os/">OS</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/mit6.s081/lab5-copy-on-write/">
    <span class="title">« Prev</span>
    <br>
    <span>Lab5: copy on Write</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/mit6.s081/lab3-page-tables/">
    <span class="title">Next »</span>
    <br>
    <span>Lab3: page tables</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">momo blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
