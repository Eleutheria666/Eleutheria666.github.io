<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>MIT6.S081 on momo blog</title>
    <link>http://localhost:1313/categories/mit6.s081/</link>
    <description>Recent content in MIT6.S081 on momo blog</description>
    <image>
      <title>momo blog</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.133.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/mit6.s081/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lab9: File System</title>
      <link>http://localhost:1313/posts/mit6.s081/lab8-file-system/</link>
      <pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/mit6.s081/lab8-file-system/</guid>
      <description>Lab链接：Lab: file system (mit.edu)
Lab答案源码：MIT-6.S081-2021 at fs (github.com)
1 Large files 题目 当前xv6文件最大只能存储268 blocks的数据。你的任务是修改xv6的代码，将inode结点中的一个“直接索引”改为“二级索引”：该索引指向的block包含256个间接block的地址，每个间接block又包含256个数据block的地址，以扩大文件可存储数据的容量。
思路 将struct inode中的NDIRECT直接索引的盘块号减一，腾出一个索引用于二级索引，其他变量随之改动。此时 struct dinode和struct inode的addrs数组大小应为[NDIRECT+2]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // kernel/fs.h #define NDIRECT 11 // 12-&amp;gt;11 #define NINDIRECT (BSIZE / sizeof(uint)) #define NDOUBLEINDIRECT (NINDIRECT*NINDIRECT) #define MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT) struct dinode { // ... uint addrs[NDIRECT+2]; // [NDIRECT+1] -&amp;gt; [NDIRECT+2] }; struct inode { // .</description>
    </item>
    <item>
      <title>Lab7: Networking</title>
      <link>http://localhost:1313/posts/mit6.s081/lab7-networking/</link>
      <pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/mit6.s081/lab7-networking/</guid>
      <description></description>
    </item>
    <item>
      <title>Lab4: Trap</title>
      <link>http://localhost:1313/posts/mit6.s081/lab4-trap/</link>
      <pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/mit6.s081/lab4-trap/</guid>
      <description>2 Backtrace 题目 实现backtrace()函数：每个堆栈帧中的帧指针用于保存调用者帧指针的地址。你的回溯应该使用这些帧指针来遍历堆栈，并在每个堆栈帧中打印保存的返回地址。
在sys_sleep中插入对该函数的调用，然后运行bttest，该命令调用sys_sleep，打印出当前堆栈上的函数调用列表。打印的结果如下：
1 2 3 4 backtrace: 0x0000000080002cda 0x0000000080002bb6 0x0000000080002898 退出qemu，使用addr2line -e kernel/kernel命令并输入上述结果，得到指定位置函数的函数名和所在文件
1 2 3 4 5 6 7 8 9 $ addr2line -e kernel/kernel 0x0000000080002de2 0x0000000080002f4a 0x0000000080002bfc Ctrl-D # output kernel/sysproc.c:74 kernel/syscall.c:224 kernel/trap.c:85 思路 在kernel/riscv.c文件中添加用于读取当前栈顶寄存器值的函数r_fp 由于每个用户进程的栈只有一页的空间大小，使用PGROUNDDOWN()获取栈所在页的首位值 遍历栈，对于每一个栈帧打印调用生成该栈帧的函数地址return address，并通过to prev frame获得下一个栈帧的地址（地址往Low处走） 源码 </description>
    </item>
  </channel>
</rss>
