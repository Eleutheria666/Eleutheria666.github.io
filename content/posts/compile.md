---
title: compile
date: 2024-09-12
description: compile
tags: ["cpp","install&configure"]
aliases: ["/cpp-compile"]
---

# 编译的过程

预编译：源代码的预编译指令替换。宏替换、条件预编译指令、**头文件展开`#<include>`**、**`#pragma`**

`gcc -E hello.c -o hello.i`

编译：源代码→汇编代码

`gcc -S hello.i -o hello.s`

汇编：汇编代码→目标代码

`gcc -c hello.s -o hello.o`

链接：将多个可重定位目标文件、库文件进行链接

`gcc hello1.o hello2.o -o hello `



# 动态库和静态库

概念：

- 静态库：在编译时，静态库的代码被直接嵌入到最终的可执行文件中。
- 动态库：在编译时，动态库的代码不会被嵌入到可执行文件中。而是在运行时，系统动态地加载动态库文件到内存中，并将其映射到进程的地址空间中。

文件名：

- Linux系统下，静态库后缀为`.a`，动态库后缀为`.so`
- Windows系统下，静态库后缀为`.lib`，动态库后缀为`.dll`

所在位置

- Linux系统下，头文件在`/usr/include/`下，库文件在`/usr/lib64`下

从以下三个角度分析静态库和动态库的**适用场景**：

- **加载时间**：使用静态库的程序启动时**不需要额外的加载时间**；使用动态库的程序由于需要在运行时加载动态库到进程的地址空间，需要额外的加载时间。
- 由于静态库的代码与程序的其他部分紧密地结合在一起，因此可能获得更好的**性能优化**。

- **内存占用**：由于每个静态库在使用它的程序都会有一份代码的拷贝，因此使用静态库内存占用较高。特别是当多个程序同时使用相同的静态库时，这种内存浪费更加明显。而动态库允许**多个程序共享同一份库代码**，内存占用较低。当系统加载动态库时，它会在内存中为库代码创建一个单独的段，并将该段的地址**映射到每个使用它的进程的地址空间中**。
- **更新与维护**：所有使用静态库的程序在其更新时都**需要重新编译**。因为静态库的代码已经嵌入到可执行文件中，所以无法单独更新库文件。动态库更新后，只需替换旧的动态库文件即可，无需重新编译使用它的程序。









参考文章

[Linux - 编译器 - 掘金 (juejin.cn)](https://juejin.cn/post/7284143489737981992?share_token=D3852499-09A5-49D3-A34D-48ADD3032891)

https://mp.weixin.qq.com/s/u1V_T8cSbL3TC_kq5lWaQw